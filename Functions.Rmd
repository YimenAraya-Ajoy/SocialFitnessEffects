---
title: "Functions"
author: "Yimen"
date: "9/25/2021"
output: html_document
---

```{r packages, echo=FALSE, message=FALSE}
rm(list=ls())
require(arm)
require(dplyr)
require(MASS)
require(ggplot2)
require(ggpubr)
library(parallel)
require(lattice)
library(latticeExtra)
require(gridExtra)
require(pander)
require(xtable)
setwd("/home/yi/Dropbox/SocialFitnessEffects")
library(RColorBrewer)

cols=c("black", "darkgreen", "red")
alpha=0.2
```

IBsim() accepts as arguments a list x that contains all the parameter values to simulate, and iterates over n.years. The simulations are stored in lists so it is easier to parallelize later on. 

```{r FunctionSimulate, echo=FALSE}
IBsim <- function(x){
  # initialize lists
  dAll<-list(IndData=list(), PopData=list())
  d<-list(Ind=list(), Pop=list())  # 
  dyears<-list() # a list of ind data for each year 
  
  
  #---- Among year variation ----
  # Simulate among year variation for each of n.years where
  # VYs is the among year variation in survival
  # VYr is the among year variation in reproduction
  # VYrs is the among-year covariance between survival and reproduction
  MY<-matrix(c(x$VYs, x$VYrs, x$VYrs, x$VYr),2,2)  # generate variance-covariance matrix
  Y<- as.data.frame(cbind(1:x$n.years, mvrnorm(x$n.years, c(0,0), MY)))
  colnames(Y) <- c("year", "Ys", "Yr")   # Ys/Yr are annual variation in survival and repro
  
  
  ##############################
  # Create founder population
  ##############################
  
  #---- Intrinsic values ----
  # Simulate individual intrinsic values for the founder population
  # nA is the number of adults in the founder population
  # VIr is the among individual variance in number of recruits
  # VIrs is the among individual variance in survival
  # VIrs is a pheniotype that could affect reproduction or survival
  
  # adults:
  df1<-data.frame(ID=1:(x$nA+x$nJ),                      # individual ID
                  Ir=rnorm(x$nA+x$nJ, 0, x$VIr),       # intrinsic reproductive value    
                  Is=rnorm(x$nA+x$nJ, 0, x$VIs),       # intrinsic survival value
                  z=rnorm(x$nA+x$nJ, 0, sqrt(x$Vaz)), # phenotypic trait value
                  age=c(rep(1, each=x$nA),rep(0, each=x$nJ)))                          # set age of adults to 1  
  
  # first breeding year individuals: 
  
  # Combine the adult and juvenile data into a data frame for year 1:
  d1 <- df1 %>%                   # combine adult and juvenile data 
        mutate(z_bar=mean(z),                     # calculate avg phenotype in year 1
               year=1,                            # year 
               N=nrow(.))                         # total population size in year 1
  
  
  #---- Residual values ----
  # Simulate the stochasticity that affects an individual's rep. or survival in a given year 
  MR<-matrix(c(x$VEs, x$VErs, x$VErs, x$VEr),2,2) # variance-covariance matrix
  E<-mvrnorm(nrow(d1), c(0,0), MR)
  colnames(E) <- c("Es", "Er")                    # added column names for subsetting (matches)
  

  
  #---- Model survival ----
  # calculate survival on the latent scale: 
  d1$sm <- x$s +             # average population survival 
           d1$Is +           # intrinsic survival value
           x$Bzs*(d1$z) +    # effect of phenotype on survival
           Y$Ys[1]  +        # annual variation in survival
           d1$N*x$Bns +      # density regulation
           x$as*d1$age +     # age effect
           E[,"Es"]          # residual effect
  
  d1$pr = (1/(1+exp(-d1$sm))) # transform to individual survival probabilities
  d1$surv<-rbinom(length(d1$sm),1,d1$pr) # realization for survival
  
  
  #---- Model reproduction ----
  # calculate survival on the latent scale (following same logic as survival): 
  d1$rm<- x$r + d1$Ir + x$Bzr*(d1$z) + Y$Yr[1]  + d1$N*x$Bnr + x$ar*d1$age + E[,"Er"]
 
  # the exponent of the latent trait defines the mean for the poisson process
  d1$recruits<-rpois(length(d1$rm), exp(d1$rm)) 
  
  
  #---- Calculate fitness ----
  d1$w<-d1$recruits + d1$surv  # individual fitness (the sum of survivial and no. recruits)
  d1$rw<-d1$w/mean(d1$w)       # relative fitness
  
  
  #---- Store data for year 1 ----
  # add individual data for year 1 to list dyears
  dyears[[1]]<-d1 
  
  # initialize a dataframe of population-level data for year 1
  pop <- data.frame(scenID=x$scenID,                                # scenario ID
                    year=1,                                         # year
                    N=x$nJ+x$nA,                                    # total population size
                    lambda=log(sum(d1$recruits+d1$surv)/d1$N[1]),   # growth rate 
                    z_bar=d1$z_bar[1],                              # mean phenotype (previously "z")
                    deltaz=d1$z_bar[1]+cov(d1$z, d1$rw))            # expected change in mean phenotype
  
  
  ##############################
  # Iterate over n.years
  ##############################
  

    for(i in 2:x$n.years){
      
      # Create temporary data with individuals of the previous generation 
      dtmp<-as.data.frame(dyears[[i-1]])
      
      if(sum(dtmp$surv)==0 & sum(dtmp$recruits)==0){
        break
      }  # if no individuals survive or reproduce, stop the loop 
      
      
      #---- Surviving adults ----    
      # Only the surviving adults make it to the current generation 
      dA2<-dtmp[dtmp$surv==1, c("ID", "Ir", "Is", "z")]
      dA2$age<-1 + dtmp$age[dtmp$surv==1] # increase their age
      
      #---- Create new recruits ----
      # Recruits enter the current generation, they have the same characteristics of the parents   
      Ir=rep(dtmp$Ir, dtmp$recruits)
      Is=rep(dtmp$Is, dtmp$recruits)
      z=rep(dtmp$z, dtmp$recruits)
      
      Vz<-mean((z-mean(z))^2)
      # Add intrinsic survival and reproduction merits for the new recruits 
      if (length(Ir)>0) {
        # generate unique ID for new recruits: year - parent ID - within-year ID
        dJ2<-data.frame(ID=(max(dtmp$ID)+1):(max(dtmp$ID)+sum(dtmp$recruits)))
        # calculate intrinsic value: parental value * heritability + error
        dJ2$Ir=Ir
        dJ2$Is=Is
        # calculate phenotypic value for new recruits 
        if(Vz>x$Vaz){
        dJ2$z= z 
        }else{
          dJ2$z= z + rnorm(length(z), 0, sqrt(x$Vaz-Vz))
        }
          # age of new recruits = 0
        dJ2$age<-0
      } # end recruit loop
      
      
      #---- Store individual data for the current year ---- 
      
      #--- hide these clauses for now and see if we get an error
      #--- ... see rbind() below
      # If some individuals survive and some reproduced combines the data into d2
      #if(nrow(dA2)>0 & length(Ir)>0){
      #  d2<-rbind(dA2,  dJ2)
      #}
      
      # If some individuals survive but nobody reproduced, d2 is composed by only adults of previous year 
      #if(nrow(dA2)>0 & length(Ir)==0){
      #  d2<-dA2
      #}
      # If no adult survives but some reproduce, d2 is composed of only juveniles:     
      #if(nrow(dA2)==0 & length(Ir)>0){
      #  d2<-dJ2
      #}
      
      d2 <- rbind(dA2, dJ2) %>%
        mutate(year=i, 
               N=nrow(.)) # Population size in current year
      
  
      # Simulate stochastic variation for individual yearly survival and reproduction
      MR<-matrix(c(x$VEs, x$VErs, x$VErs, x$VEr),2,2)
      E<-matrix(mvrnorm(nrow(d2), c(0,0), MR),nrow(d2),2)
      colnames(E) <- c("Es", "Er")
      
      # Age as a categorical value and mean phenotype
      age2<-d2$age
      age2[d2$age>0]<-1
      d2$z_bar<-mean(c(dA2$z,dJ2$z))
      
      
      #---- Calculate survival and reproduction ----
      # Follows same logic as year 1, 
      # but with extra terms reflecting the interactions between population size and mean phenotype
      
      # calculate survival on the latent scale:
      d2$sm <- x$s + x$as*age2  + d2$Is + Y$Ys[i] + x$Bzs*d2$z +     d2$N*x$Bns +  E[,"Es"]
      x$BZs*d2$z_bar +             # social selection 
        x$BZns*d2$N*d2$z_bar +     # phenotype-dependent density regulation
        x$Bzns*d2$N*d2$z  +        # density-dependent selection
        x$BZzs*d2$z*d2$z_bar +     # frequency-dependent selection
        x$BZzns*d2$z*d2$z_bar*d2$N # link between density- and frequency-dependent selection
      
      # probability of survival: 
      d2$pr = (1/(1+exp(-d2$sm))) 
      
      # realized survivial: 
      d2$surv<-rbinom(length(d2$sm),1,d2$pr) # realization
      
      # calculcate reproduction on the latent scale
      d2$rm <- x$r + x$ar*age2 +  d2$Ir + Y$Yr[i] + x$Bzr*d2$z + 
        x$Bzr2*d2$z^2 + d2$N*x$Bnr + E[,"Er"] + 
        x$BZr*d2$z_bar + 
        x$BZnr*d2$N*d2$z_bar + 
        x$Bznr*d2$N*d2$z  + 
        x$BZzr*d2$z*d2$z_bar+ 
        x$BZznr*d2$z*d2$z_bar*d2$N  
     
       # realized reproduction
      d2$recruits<-rpois(length(d2$rm), exp(d2$rm)) 
      
      # calculate fitness 
      d2$w<-d2$recruits + d2$surv    
      d2$rw<-d2$w/mean(d2$w)
      
      # add individual data for year i to list dyears 
      dyears[[i]]<-d2
      
      # add population-level data for current year to pop dataframe 
      pop <- pop %>% 
        add_row(scenID=x$scenID,                                  # scenario ID
                year=i,                                           # year
                N=sum(dtmp$recruits + dtmp$surv),                 # total population size
                z_bar=d2$z_bar[1],                                # mean phenotype (previously "z")
                lambda=log(sum(d2$recruits + d2$surv)/d2$N[1]),   # growth rate
                deltaz=mean(d2$z)+cov(d2$z, d2$rw))               # expected change in mean phenotype
    } # end loop

  
  #---- Format data ----
  dtmp1<-do.call(rbind.data.frame, dyears)  # combine ind. data for all years into a dataframe 
  dtmp1$simID<- x$sim                         # simulation ID
  dtmp1$scenID<- x$scenID 
  pop$simID <- x$sim                          # column for simulationID
  pop$scenID <- x$scenID
  # column for simulation 
  
  dAll$IndData<-dtmp1                       # add yearly data to a list
  dAll$PopData<-pop                         # add population data to a list
  dAll$Param<-x
  dAll
  }
```

Function sim.pop() accepts a vector of all parameter values and number of simulations and iterates IBsim() over n.sims. It returns a list. 
```{r FunctionSimPops, echo=FALSE}

sim.pops <- function(x, n.sims, n.Cores=detectCores()-1, seed=FALSE){  
  lists<-list()  # initialize list of parameter values for each scenario
  for(j in 1:n.sims){
    lists[[j]]<- cbind(x, sim=j)  # create list of paramter values (all same) and simulation ID (unique)
  }    
  
  res <- mclapply(lists, IBsim, mc.cores=n.Cores, mc.set.seed=seed) 
  res
  }

make.dataframe<-function(x){
  d<- list()
  d$Ind<-do.call(rbind.data.frame, lapply(x, '[[', 1))
  d$Pop<-do.call(rbind.data.frame, lapply(x, '[[', 2)) 
  d$Params<-as.data.frame(x$params)
  d
  
}

```

A function to generate x (a data frame of parameter values). Function has set defaults so that it's easy to see what differs between scenarios. 
All the parameter values we need for the simulations will be subset from x. 
```{r FunctionCreateX, echo=FALSE}
# A function to calculate x. Function contains default values so that it is clear what is changing in each scenario. 
# scenID is scenario ID
# n.years is the number of years per simulation
create.x <- function(scenID, n.years=200, s=-0.1, r=0.1, Bns=0, Bnr=-0.01, nJ=10, nA=10,ar=0, as=0, h2r=0, h2s=0, h2rs=1, VYs=0, VYr=0, VYrs=0, VIr=0, VIs=0,  Vaz=1, VEs=0, VEr=0, VErs=0, Bzr=0, Bzr2=0, Bzs=0, BZr=0, BZs=0, BZnr=0, BZns=0, Bznr=0, Bzns=0, BZzr=0,  BZzs=0, BZznr=0,  BZzns=0){
  data.frame(scenID=scenID, n.years=n.years, s=s, r=r, Bns=Bns, Bnr=Bnr, nJ=nJ, nA=nA,
             ar=ar, as=as, h2r=h2r, h2s=h2s, h2rs=h2rs,
             VYs=VYs, VYr=VYr, VYrs=VYrs, VIs=VIs, VIr=VIr, Vaz=Vaz, VEs=VEs, VEr=VEr, 
             VErs=VErs, Bzr=Bzr, Bzr2=Bzr2, Bzs=Bzs, BZr=BZr, BZs=BZs, BZnr=BZnr, BZns=BZns,
             Bznr=Bznr, Bzns=Bzns, BZzr=BZzr, BZzs=BZzs, BZznr=BZznr, BZzns=BZzns)
}
```


Functions for analyzing the data:

This function combines Nbar(), zbar() to calculate the average population size and mean phenotype for each year across simulations, and the proportion of simulations that went extinct. a, b, and c are the outputs from sim.pops() for three different scenarios. 

```{r FunctionCalcSimAvg, echo=FALSE}
# this function combines functions Nbar() and zbar()
# accepts as arguments the output of sim.pops for three scenarios (a, b,c) and calculates the avg yearly population size and phenotype accross all simulations in each scenario
calc.simAvg <- function(a, b, c){
    rbind(a$Pop, b$Pop, c$Pop) %>%                # combine data from all scenarios
    group_by(scenID, year) %>%                    # for each year in each scenario, calculate... 
    summarize(Nbar = mean(N, na.rm=TRUE),         # mean population size 
              zbar = mean(z_bar, na.rm=TRUE),     # mean phenotype
              sigma2z = var(z_bar, na.rm=TRUE)) 
}

calc.YearlySigma <- function(a, b, c){
    rbind(a$Ind, b$Ind, c$Ind) %>%                # combine data from all scenarios
    group_by(scenID, year) %>%                    # for each year in each scenario, calculate... 
    summarize(sigma2z = var(z_bar, na.rm=TRUE)) 
}


```

```{r FunctionExtinction, echo=FALSE}
# a function to calculate extinction (replaces Ext())
calc.ext <- function(a, b, c){
    rbind(a$Pop, b$Pop, c$Pop) %>%
    group_by(scenID, sim) %>% 
    summarize(max.year=max(year), .group='keep') %>%
    mutate(prop.ext=sum(max.year<100)/max(sim)) %>%
    group_by(scenID) %>% summarize(ext=mean(prop.ext), )
}
```

```{r FunctionAnalyze, echo=FALSE}
model.1<-function(x){
mod<-lm(w~N, data=x)
B1=coef(mod)[1]
Bn=coef(mod)[2]

EN=as.vector(-(B1-1)/Bn)

res<-data.frame(N=x$N[x$year==max(x$year)][1], z=mean(x$z[x$year==max(x$year)]), Vz=var(x$z[x$year==max(x$year)]), EN=EN, Ez=NA, B1, Bn)
res$biasN=as.vector(res$EN-res$N)
res$scenID=x$scenID[1]
res
}

model.2<-function(x){
x$z2<-x$z^2
mod<-lm(w~N + z + z2, data=x)
B1=coef(mod)[1]
Bn=coef(mod)[2]
Bl=coef(mod)[3]
Bq=coef(mod)[4]
zp=(-Bl/(2*Bq))
EN=as.vector(-(B1 + Bl*zp + Bq*zp^2+Bq*var(x$z[x$year==max(x$year)])-1)/Bn)

res<-data.frame(N=x$N[x$year==max(x$year)][1], z=mean(x$z[x$year==max(x$year)]), Vz=var(x$z[x$year==max(x$year)]), EN=EN, Ez=zp, B1, Bn, Bl, Bq)
res$scenID=x$scenID[1]
res$biasN=as.vector(res$EN-res$N)
res
}

model.3<-function(x){
x$z2<-x$z^2
mod<-lm(w~N + z + z2 +  z_bar , data=x)
B1=coef(mod)[1]
Bn=coef(mod)[2]
Bl=coef(mod)[3]
Bq=coef(mod)[4]
Bz=coef(mod)[5]
zp=(-Bl/(2*Bq))

EN=(-1 + B1 + Bl*zp + Bz*zp+  Bq*zp^2  + Bq*var(x$z[x$year==max(x$year)]))/-(Bn)

res<-data.frame(N=x$N[x$year==max(x$year)][1], z=mean(x$z[x$year==max(x$year)]), Vz=var(x$z[x$year==max(x$year)]),  EN=EN, Ez=zp, B1, Bn, Bl, Bq, Bz)
res$scenID=x$scenID[1]
res$biasN=as.vector(res$EN-res$N)
res
}

model.4<-function(x){
x$z2<-x$z^2
mod<-lm(w~ N + z + z2 + z_bar + z_bar:N , data=x)
B1=coef(mod)[1]
Bn=coef(mod)[2]
Bl=coef(mod)[3]
Bq=coef(mod)[4]
Bz=coef(mod)[5]
Bnz=coef(mod)[6]
zp=(-Bl/(2*Bq))

EN=(-1 + B1 + Bl*zp + Bz*zp+  Bq*zp^2  + Bq*var(x$z[x$year==max(x$year)]))/-(Bn + Bnz*zp)


res<-data.frame(N=x$N[x$year==max(x$year)][1], z=mean(x$z[x$year==max(x$year)]), Vz=var(x$z[x$year==max(x$year)]),  EN=EN, Ez=zp, B1, Bn, Bl, Bq, Bz, Bnz)
res$scenID=x$scenID[1]
res$biasN=as.vector(res$EN-res$N)
res
}

model.5<-function(x){
x$z2<-x$z^2
mod<-lm(w~ N + z + z2 + z:N  , data=x)
B1=coef(mod)[1]
Bn=coef(mod)[2]
Bl=coef(mod)[3]
Bq=coef(mod)[4]
Bzn=coef(mod)[5]
N=x$N[x$year==max(x$year)][1]
s=var(x$z[x$year==max(x$year)])

zp<--(Bl - (Bl*Bzn - 2*Bn*Bq + 2*sqrt(Bq^2*Bzn^2*s + B1*Bq*Bzn^2 - Bl*Bn*Bq*Bzn + Bn^2*Bq^2 - Bq*Bzn^2))/Bzn)/(2*Bq)

EN=-(Bl*Bzn - 2*Bn*Bq + 2*sqrt(Bq^2*Bzn^2*s + B1*Bq*Bzn^2 - Bl*Bn*Bq*Bzn + Bn^2*Bq^2 - Bq*Bzn^2))/Bzn^2

res<-data.frame(N=x$N[x$year==max(x$year)][1], z=mean(x$z[x$year==max(x$year)]), Vz=var(x$z[x$year==max(x$year)]),  EN=EN, Ez=zp, B1, Bn, Bl, Bq, Bzn)
res$scenID=x$scenID[1]
res$biasN=as.vector(res$EN-res$N)
res
}

model.6<-function(x){
x$z2<-x$z^2
mod<-lm(w~ N + z + z2 + z_bar + z:z_bar  , data=x)
B1=coef(mod)[1]
Bn=coef(mod)[2]
Bl=coef(mod)[3]
Bq=coef(mod)[4]
Bz=coef(mod)[5]
Bzz=coef(mod)[6]
zp<--(Bl)/(2*Bq + Bzz)

EN=(-1 + B1 + (Bl + Bz)*zp  +  (Bzz + Bq)*zp^2 + Bq*var(x$z[x$year==max(x$year)]))/-Bn

res<-data.frame(N=x$N[x$year==max(x$year)][1], z=mean(x$z[x$year==max(x$year)]), Vz=var(x$z[x$year==max(x$year)]),  EN=EN, Ez=zp, B1, Bn, Bl, Bq, Bz, Bzz)
res$scenID=x$scenID[1]
res$biasN=as.vector(res$EN-res$N)
res
}

model.7<-function(x){
x$z2<-x$z^2
mod<-lm(w~ N + z + z2 + z_bar + z_bar:N + z:N + z_bar:z + z_bar:N:z, data=x)
B1=coef(mod)[1]
Bn=coef(mod)[2]
Bl=coef(mod)[3]
Bq=coef(mod)[4]
Bz=coef(mod)[5]
BNZ=coef(mod)[6]
BNz=coef(mod)[7]
BZz=coef(mod)[8]
BNZz=coef(mod)[9]

N=x$N[x$year==max(x$year)][1]

zp<--(Bl + BNz*N)/(2*Bq + BZz + BNZz*N)

EN=(-1 + B1 + (Bl + Bz)*zp  +  (BZz + Bq)*zp^2 + Bq*var(x$z[x$year==max(x$year)]))/-(Bn + BNz*zp + BNZz*zp^2 + BNZ*zp) 

res<-data.frame(EN=EN, N=N, Ez=zp, z=mean(x$z[x$year==max(x$year)]), Vz=var(x$z[x$year==max(x$year)]),B1, Bn, Bl, Bq, Bz, BNZ, BNz, BZz, BNZz)
res$scenID=x$scenID[1]
res$biasN=as.vector(res$EN-res$N)
res
}

analyze<-function(x,y,z, model){
an1<-do.call(rbind.data.frame,mclapply(lapply(x, '[[', 1), model, mc.cores=3))
an2<-do.call(rbind.data.frame,mclapply(lapply(y, '[[', 1), model, mc.cores=3))
an3<-do.call(rbind.data.frame,mclapply(lapply(z, '[[', 1), model, mc.cores=3))
b<-rbind(an1,an2,an3)
}
```

```{r FunctionsPredict, echo=FALSE}

predict1<-function(x, y){
x<-as.data.frame(x)
n<-seq(1:y)  
w1=x$B1[1] + x$Bn[1]*n
w2=x$B1[2] + x$Bn[2]*n
w3=x$B1[3] + x$Bn[3]*n
res<-data.frame(w=c(w1,w2,w3),n, scenID=rep(x$scenID, each=y))
res
}


predict2<-function(x, y){
x<-as.data.frame(x)
n<-seq(1:y)  
w1=x$B1[1] + x$Bn[1]*n + x$Bl[1]*x$Ez[1] + x$Bq[1]*x$Ez[1]^2 + x$Bq[1]*x$Vz[1]
w2=x$B1[2] + x$Bn[2]*n + x$Bl[2]*x$Ez[2] + x$Bq[2]*x$Ez[2]^2 + x$Bq[2]*x$Vz[2]
w3=x$B1[3] + x$Bn[3]*n + x$Bl[3]*x$Ez[3] + x$Bq[3]*x$Ez[3]^2 + x$Bq[3]*x$Vz[3]
res<-data.frame(w=c(w1,w2,w3),n, scenID=rep(x$scenID, each=y))
res
}

predict3<-function(x, y){
x<-as.data.frame(x)
n<-seq(1:y)  
w1=x$B1[1] + x$Bn[1]*n + x$Bl[1]*x$Ez[1] + x$Bq[1]*x$Ez[1]^2 + x$Bq[1]*x$Vz[1] + x$Bz[1]*x$Ez[1]
w2=x$B1[2] + x$Bn[2]*n + x$Bl[2]*x$Ez[2] + x$Bq[2]*x$Ez[2]^2 + x$Bq[2]*x$Vz[2] + x$Bz[2]*x$Ez[2]
w3=x$B1[3] + x$Bn[3]*n + x$Bl[3]*x$Ez[3] + x$Bq[3]*x$Ez[3]^2 + x$Bq[3]*x$Vz[3] + x$Bz[3]*x$Ez[3]
res<-data.frame(w=c(w1,w2,w3),n, scenID=rep(x$scenID, each=y))
res
}

predict4<-function(x, y){
x<-as.data.frame(x)
n<-seq(1:y)  
w1=x$B1[1] + x$Bn[1]*n + x$Bl[1]*x$Ez[1] + x$Bq[1]*x$Ez[1]^2 + x$Bq[1]*x$Vz[1] + x$Bz[1]*x$Ez[1] + x$Bnz[1]*x$Ez[1]*n
w2=x$B1[2] + x$Bn[2]*n + x$Bl[2]*x$Ez[2] + x$Bq[2]*x$Ez[2]^2 + x$Bq[2]*x$Vz[2] + x$Bz[2]*x$Ez[2] + x$Bnz[2]*x$Ez[2]*n
w3=x$B1[3] + x$Bn[3]*n + x$Bl[3]*x$Ez[3] + x$Bq[3]*x$Ez[3]^2 + x$Bq[3]*x$Vz[3] + x$Bz[3]*x$Ez[3]  + x$Bnz[3]*x$Ez[3]*n
res<-data.frame(w=c(w1,w2,w3),n, scenID=rep(x$scenID, each=y))
res
}

predict5<-function(x, y){
x<-as.data.frame(x)
n<-seq(1:y)  
w1=x$B1[1] + x$Bn[1]*n + x$Bl[1]*x$Ez[1] + x$Bq[1]*x$Ez[1]^2 + x$Bq[1]*x$Vz[1] + x$Bz[1]*x$Ez[1] + x$Bzn[1]*n*x$Ez[1]

w2=x$B1[2] + x$Bn[2]*n + x$Bl[2]*x$Ez[2] + x$Bq[2]*x$Ez[2]^2 + x$Bq[2]*x$Vz[2] + x$Bz[2]*x$Ez[2] + x$Bzn[2]*n*x$Ez[2]


w3=x$B1[3] + x$Bn[3]*n + x$Bl[3]*x$Ez[3] + x$Bq[3]*x$Ez[3]^2 + x$Bq[3]*x$Vz[3] + x$Bz[3]*x$Ez[3] + x$Bzn[3]*n*x$Ez[3]
res<-data.frame(w=c(w1,w2,w3),n, scenID=rep(x$scenID, each=y))
res
}

predict6<-function(x, y){
x<-as.data.frame(x)
n<-seq(1:y)  
w1=x$B1[1] + x$Bn[1]*n + x$Bl[1]*x$Ez[1] + x$Bq[1]*x$Ez[1]^2 + x$Bq[1]*x$Vz[1] + x$Bz[1]*x$Ez[1] +  x$Bzz[1]*x$Ez[1]^2
w2=x$B1[2] + x$Bn[2]*n + x$Bl[2]*x$Ez[2] + x$Bq[2]*x$Ez[2]^2 + x$Bq[2]*x$Vz[2] + x$Bz[2]*x$Ez[2] + x$Bzz[2]*x$Ez[2]^2
w3=x$B1[3] + x$Bn[3]*n + x$Bl[3]*x$Ez[3] + x$Bq[3]*x$Ez[3]^2 + x$Bq[3]*x$Vz[3] + x$Bz[3]*x$Ez[3]  + x$Bzz[3]*x$Ez[3]^2
res<-data.frame(w=c(w1,w2,w3),n, scenID=rep(x$scenID, each=y))
res
}


predict7<-function(x, y){
x<-as.data.frame(x)
n<-seq(1:y)  

w1=x$B1[1] + x$Bn[1]*n + x$Bl[1]*x$Ez[1] + x$Bq[1]*x$Ez[1]^2 + x$Bq[1]*x$Vz[1] + x$Bz[1]*x$Ez[1] +  x$BNZ[1]*x$Ez[1]*n + x$BNz[1]*x$Ez[1]*n + x$BZz[1]*x$Ez[1]^2 + x$BNZz[1]*x$Ez[1]^2*n

w2=x$B1[2] + x$Bn[2]*n + x$Bl[2]*x$Ez[2] + x$Bq[2]*x$Ez[2]^2 + x$Bq[2]*x$Vz[2] + x$Bz[2]*x$Ez[2] +  x$BNZ[2]*x$Ez[2]*n + x$BNz[2]*x$Ez[2]*n + x$BZz[2]*x$Ez[2]^2 + x$BNZz[2]*x$Ez[2]^2*n

w3=x$B1[3] + x$Bn[3]*n + x$Bl[3]*x$Ez[3] + x$Bq[3]*x$Ez[3]^2 + x$Bq[3]*x$Vz[3] + x$Bz[3]*x$Ez[3] +  x$BNZ[3]*x$Ez[3]*n + x$BNz[3]*x$Ez[3]*n + x$BZz[3]*x$Ez[3]^2 + x$BNZz[3]*x$Ez[3]^2*n

res<-data.frame(w=c(w1,w2,w3),n, scenID=rep(x$scenID, each=y))
res
}


popdyn1<-function(x,y){
x<-as.data.frame(x)
dndt<-w<-N<-matrix(NA,y,3)
dndt3<-dndt2<-dndt<-w<-N<-N2<-N3<-matrix(NA,y,3)
N3[1,]<-N2[1,]<-N[1,]<-10

r<-x$B1
for(i in 1:(y-1)){
  w[i,]<-r + x$Bn*N[i,]
  N[i+1,]<-N[i,]*w[i,]
  dndt[i,]<-N[i+1,]-N[i,]
  dndt2[i,]<-N2[i,]*log(r)*(1-(N2[i,]/x$EN))
  N2[i+1,]<-N2[i,]+dndt2[i,]
  dndt3[i,]<-N3[i,]*log(r)*(1-(N3[i,]/x$EN)^1.51)
  N3[i+1,]<-N3[i,]+dndt3[i,]
}

res<-data.frame(N=matrix(N,y*3), N2=matrix(N2,y*3), N3=matrix(N3,y*3),w=matrix(w,y*3), dndt=matrix(dndt,y*3), year=1:y, scenID=as.factor(rep(x$scenID,each=y)))
res}


popdyn2<-function(x,y){
x<-as.data.frame(x)
dndt<-w<-N<-matrix(NA,y,3)
dndt3<-dndt2<-dndt<-w<-N<-N2<-N3<-matrix(NA,y,3)
N3[1,]<-N2[1,]<-N[1,]<-10

r<-x$B1 + x$Bl*x$Ez + x$Bq*x$Ez^2 + x$Bq*x$Vz
for(i in 1:(y-1)){
  w[i,]<-r + x$Bn*N[i,]
  N[i+1,]<-N[i,]*w[i,]
  dndt[i,]<-N[i+1,]-N[i,]
  dndt2[i,]<-N2[i,]*log(r)*(1-(N2[i,]/x$EN))
  N2[i+1,]<-N2[i,]+dndt2[i,]
  dndt3[i,]<-N3[i,]*log(r)*(1-(N3[i,]/x$EN)^1.51)
  N3[i+1,]<-N3[i,]+dndt3[i,]
}

res<-data.frame(N=matrix(N,y*3), N2=matrix(N2,y*3), N3=matrix(N3,y*3),w=matrix(w,y*3), dndt=matrix(dndt,y*3), year=1:y, scenID=as.factor(rep(x$scenID,each=y)))
res

}

popdyn3<-function(x,y){
x<-as.data.frame(x)
dndt<-w<-N<-matrix(NA,y,3)
dndt3<-dndt2<-dndt<-w<-N<-N2<-N3<-matrix(NA,y,3)
N3[1,]<-N2[1,]<-N[1,]<-10
r<-x$B1 + x$Bl*x$Ez + x$Bq*x$Ez^2 + x$Bq*x$Vz + x$Bz*x$Ez
for(i in 1:(y-1)){
  w[i,]<-r + x$Bn*N[i,]
  N[i+1,]<-N[i,]*w[i,]
  dndt[i,]<-N[i+1,]-N[i,]
  dndt2[i,]<-N2[i,]*log(r)*(1-(N2[i,]/x$EN))
  N2[i+1,]<-N2[i,]+dndt2[i,]
  dndt3[i,]<-N3[i,]*log(r)*(1-(N3[i,]/x$EN)^1.51)
  N3[i+1,]<-N3[i,]+dndt3[i,]
}

res<-data.frame(N=matrix(N,y*3), N2=matrix(N2,y*3), N3=matrix(N3,y*3),w=matrix(w,y*3), dndt=matrix(dndt,y*3), year=1:y, scenID=as.factor(rep(x$scenID,each=y)))
res
}

popdyn4<-function(x,y){
x<-as.data.frame(x)
dndt<-w<-N<-matrix(NA,y,3)
dndt3<-dndt2<-dndt<-w<-N<-N2<-N3<-matrix(NA,y,3)
N3[1,]<-N2[1,]<-N[1,]<-10
r<-x$B1 + x$Bl*x$Ez + x$Bq*x$Ez^2 + x$Bq*x$Vz + x$Bz*x$Ez

for(i in 1:(y-1)){
  w[i,]<-r + (x$Bn + x$Bnz*x$Ez)*N[i,]
  N[i+1,]<-N[i,]*w[i,]
  dndt[i,]<-N[i+1,]-N[i,]
  dndt2[i,]<-N2[i,]*log(r)*(1-(N2[i,]/x$EN))
  N2[i+1,]<-N2[i,]+dndt2[i,]
  dndt3[i,]<-N3[i,]*log(r)*(1-(N3[i,]/x$EN)^1.51)
  N3[i+1,]<-N3[i,]+dndt3[i,]
}

res<-data.frame(N=matrix(N,y*3), N2=matrix(N2,y*3), N3=matrix(N3,y*3),w=matrix(w,y*3), dndt=matrix(dndt,y*3), year=1:y, scenID=as.factor(rep(x$scenID, each=y)))
}

popdyn5<-function(x,y){
x<-as.data.frame(x)
dndt<-w<-N<-matrix(NA,y,3)
dndt3<-dndt2<-dndt<-w<-N<-N2<-N3<-matrix(NA,y,3)
N3[1,]<-N2[1,]<-N[1,]<-10
r<-x$B1 + x$Bl*x$Ez + x$Bq*x$Ez^2 + x$Bq*x$Vz + x$Bz*x$Ez

for(i in 1:(y-1)){
  w[i,]<-r +  (x$Bn + x$Bzn*x$Ez)*N[i,]
  N[i+1,]<-N[i,]*w[i,]
  dndt[i,]<-N[i+1,]-N[i,]
  dndt2[i,]<-N2[i,]*log(r)*(1-(N2[i,]/x$EN))
  N2[i+1,]<-N2[i,]+dndt2[i,]
  dndt3[i,]<-N3[i,]*log(r)*(1-(N3[i,]/x$EN)^1.51)
  N3[i+1,]<-N3[i,]+dndt3[i,]
}

res<-data.frame(N=matrix(N,y*3), N2=matrix(N2,y*3), N3=matrix(N3,y*3),w=matrix(w,y*3), dndt=matrix(dndt,y*3), year=1:y, scenID=as.factor(rep(x$scenID, each=y)))
res
 }

popdyn6<-function(x,y){
x<-as.data.frame(x)
dndt<-w<-N<-matrix(NA,y,3)
dndt3<-dndt2<-dndt<-w<-N<-N2<-N3<-matrix(NA,y,3)
N3[1,]<-N2[1,]<-N[1,]<-10
r<-x$B1 + x$Bl*x$Ez + x$Bq*x$Ez^2 + x$Bq*x$Vz +  x$Bz*x$Ez + x$Bzz*x$Ez^2
for(i in 1:(y-1)){
  w[i,]<-r +  (x$Bn)*N[i,]
  N[i+1,]<-N[i,]*w[i,]
  dndt[i,]<-N[i+1,]-N[i,]
  dndt2[i,]<-N2[i,]*log(r)*(1-(N2[i,]/x$EN))
  N2[i+1,]<-N2[i,]+dndt2[i,]
  dndt3[i,]<-N3[i,]*log(r)*(1-(N3[i,]/x$EN)^1.51)
  N3[i+1,]<-N3[i,]+dndt3[i,]
}

res<-data.frame(N=matrix(N,y*3), N2=matrix(N2,y*3), N3=matrix(N3,y*3),w=matrix(w,y*3), dndt=matrix(dndt,y*3), year=1:y, scenID=as.factor(rep(x$scenID, each=y)))
res
 }

popdyn7<-function(x,y){
x<-as.data.frame(x)
dndt<-w<-N<-matrix(NA,y,3)
dndt3<-dndt2<-dndt<-w<-N<-N2<-N3<-matrix(NA,y,3)
N3[1,]<-N2[1,]<-N[1,]<-10
r<-x$B1  + x$Bl*x$Ez + x$Bq*x$Ez^2 + x$Bq*x$Vz +  x$Bz*x$Ez +   + x$BZz*x$Ez^2 
for(i in 1:(y-1)){
  w[i,]<-r +  (x$Bn+x$BNZ*x$Ez+x$BNz*x$Ez+x$BNZz*x$Ez^2)*N[i,]
  N[i+1,]<-N[i,]*w[i,]
  dndt[i,]<-N[i+1,]-N[i,]
  dndt2[i,]<-N2[i,]*log(r)*(1-(N2[i,]/x$EN))
  N2[i+1,]<-N2[i,]+dndt2[i,]
  dndt3[i,]<-N3[i,]*log(r)*(1-(N3[i,]/x$EN)^1.51)
  N3[i+1,]<-N3[i,]+dndt3[i,]
}

res<-data.frame(N=matrix(N,y*3), N2=matrix(N2,y*3), N3=matrix(N3,y*3),w=matrix(w,y*3), dndt=matrix(dndt,y*3), year=1:y, scenID=as.factor(rep(x$scenID, each=y)))
res
 }



```
